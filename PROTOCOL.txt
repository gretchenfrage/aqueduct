The Aqueduct Protocol Specification
Pre-Release Version: 0.0.0-AFTER
---

# About this document

For pre-1.0 versions of Aqueduct, this document is given the same
version number as the package itself. Once the package and/or protocol
hits version 1.0, version numbers for the package and for the protocol
will become independent.

This is a text file with a maximum width of 73 characters. It should be
self-sufficient as a reference for someone creating their own Aqueduct
implementation.

Any code changes that change the protocol should correspond to updates
to this document to keep it up-to-date. We will become more conservative
and intentional about changing the protocol once we hit 1.0.

We use the "-AFTER" suffix on our semantic versions to denote that the
current version of the code / specification belongs to some commit after
the release-tagged commit corresponding to that version of the code, and
before the next release-tagged commit corresponding to the following
version.

Pre-1.0 versions of this document may include TODO comments with notes
on ways we would like to explore potentially enhancing the protocol. A
TODO comment noting some idea does not constitute a commitment or
promise to actually going through with it.

# QUIC

Aqueduct runs on top of QUIC. In this document, "streams" refers to QUIC
streams, whereas "channels" refers to Aqueduct channels. QUIC datagrams
are also used.

Aqueduct only uses unidirectional QUIC streams, not bidirectional QUIC
streams. The QUIC bidirectional stream limit should be set to 0, and the
opening of a bidirectional stream (which should not be possible in QUIC
if the bidirectional stream limit is set to 0) should be treated as a
protocol violation error.

Servers and client must accept datagrams (they must have enabled the
QUIC unreliable datagram extension first standardized in RFC 9221). If
they do not, they are not compliant Aqueduct implementations, and this
may be treated as a protocol error.

TODO: Fallback to TCP or WebSocket for situations where the network
      refuses to carry UDP packets.
TODO: Fallback, or completely convert to WebTransport for running within
      web frontends more perforantly than falling back to WebSocket.

# ZeroRTT

An Aqueduct client may send any data in 0-RTT streams and 0-RTT
datagrams. It must buffer all data sent on 0-RTT streams until it learns
the server accepted or rejected its 0-RTT data. If the server rejects
its 0-RTT data, it must retransmit all data it sent on a 0-RTT stream on
a new 1-RTT stream. It should not buffer and retransmit datagrams.

Clients should remember address validation tokens from NEW_TOKEN frames
and use them when making 0-RTT requests if able. Transmitting 0-RTT data
will not be beneficial if the client does not have a address validation
token, so a client may avoid bothering to do so if it doesn't.

An Aqueduct server may receive data from 0-RTT streams, but it must not
process it until it can be sure it is not coming from a replay attack.
If the client used some un-guessable and un-forgeable address validation
token, and the server maintains state capable of detecting token reuse,
and this system is guaranteed to experience no false negatives with
regard to detecting token reuse, and from this system the server knows
that the client's address validation token has never been used before,
then the server may conclude that the 0-RTT data is definitely not
coming from a replay attack, and process it immediately. In such a
system, the server must take care to ensure that this token reuse
detection state is at least as persistent as whatever cryptographic keys
or other mechanism it is using to prevent its tokens from being guessed
or forged, and that there are also no possibilities for false negatives
introduced by problems relating to token encryption keys being shared by
servers in a server farm or cluster, or by eventual consistency in
replay detection state being shared, replicated, sharded, or otherwise
distributed across different servers in a server farm or cluster, or by
lack of consistency in the face of un-graceful server shutdown, or by
systems to copy or roll back disk state, or by anything else. If the
server cannot for any reason determine with total confidence that 0-RTT
data is not coming from replay attacks, it must either reject the 0-RTT
data on the TLS level (QUIC/TLS APIs may not always make this possible),
or wait until the TLS handshake fully completes before processing that
data, at which point the completion of the TLS handshake proves the
authenticity of the 0-RTT data.

An Aqueduct server always may send data as 0.5-RTT data, and should
do so if it is or may be processing 0-RTT data.

TODO: Conveying that data was sent in 0-RTT and getting responses of
      whether it was accepted or rejected without relying on TLS API
      itself, to facilitate proxies / reverse proxies and/or limited
      TLS APIs.
TODO: Conveying the proof-of-no-replay token through some other field
      than that address validation token, to deal with limited TLS APIs.
TODO: TLS client authentication, both in general, and also getting that
      to work security in 0.5-RTT by encoding some information about a
      previously authenticated session in the token. Consider security
      issues with a client, potentially a proxy, reusing a token but
      not actually meaning to authenticate its further requests with the
      old client key. Consider whether this has tradeoffs with
      cryptographic forward security and how to navigate those.

# Endianness

Values are encoded little-endian unless stated otherwise.

# Var len ints

Sometimes, a variable length uint encoding is used. An encoded var len
int always contains at least 1 byte. The lowest 7 bits of the byte
encode the lowest 7 bits of the represented uint, and the highest bit of
the byte is a 1 if there is at least 1 more byte in the encoded var len
int. If there is another byte in the encoded var len int, the lowest 7
bits of that byte encode the next lowest 7 bits of the represented uint
(so, the 8th through 14th lowest bits), and the highest bit represents
whether there is yet another byte in the encoded uint. This pattern
continues until terminated by an encoded byte with its highest bit being
0. It must be considered a protocol violation if a var len int is
encoded in more bytes than necessary, or if it contains more than 64
bits, excepting unavoidable trailing 0 bits.

# Byte arrays

Sometimes, a length-prefixed byte array is encoded. This is encoded as a
var len int, encoding the length of the array, following by that many
bytes.

# Frames

Frames are the unit of the Aqueduct client and server sending each other
self-contained messages on the wire.

Each frame begins with a "frame type byte", a single byte indicating
what type of frame it is. Then, it may have further bytes, in accordance
with logic specific to its frame type.

It is clear from a byte sequence that begins with a frame when that
frame ends. Thus, it is possible to encode multiple frames back-to-back
without additional framing.

The client and server must listen to each other for unidirectional QUIC
streams, and also for QUIC datagrams. Both the data in a stream and the
data in a datagram is a sequence of one or more frames encoded
back-to-back.

If the data in a stream or in a datagram fails to decode as frames,
that's a protocol violation. If there's extra bytes after the frames,
that's a protocol violation, although it's unclear what that would even
mean as both streams and datagrams are allowed to contain multiple
frames and frames describe their own length implicitly. If a received
QUIC stream is elegantly finished without at least one full frame being
received on it, that's a protocol violation. If a received datagram does
not contain at least one full frame on it, that's a protocol violation.

If multiple frames are received in the same stream or datagram, they
must be processed in sequence (that is, one after the other, in the
order they are encoded). To clarify, if a frame results in a message
being delivered to the application through a channel, there is no
requirement that the application must process these messages in an order
consistent with the order the frames were encoded within the same stream
or datagram. However, there would be a requirement that the Aqueduct
implementation enqueue these messages into the channel in an order
consistent with the order of the frames themselves, as the processing
of a frame which triggers enqueueing a message into an application-
facing channel would encompass just the enqueueing of the message into
the channel, and not the dequeueing and processing of the message by the
application. Frames are abstracted away from the application.

Frames received from different streams or different datagrams may be
processed in parallel.

Parallelizing parts of the processing of frames within the same stream
or datagram is permissible only to the extent that it has no possibility
of meaningfully changing behavior / introducing race conditions.

An Aqueduct implementation does not have to care about whether a frame
came from some particular stream or datagram, or even whether it came
from a stream or a datagram, when processing it.

If a QUIC stream is cancelled, the receiving side should disregard any
partially received frames up to the point of cancellation, and does not
have to process any frames previously received from that stream if it
has not already done so.

# Frame types

The following frame type bytes and corresponding frame types exist:

- 0: Message
- 1: ConnHeaderData
- 2: AckConnectionHeaderData
- 3: Ping
- 4: Pong
- 5: IsChannelOpenRequest
- 6: IsChannelOpenResponse


# Error handling

Upon encountering a protocol error, the QUIC connection should be
immediately closed.
