The Aqueduct Protocol Specification
Pre-Release Version: 0.0.0-AFTER
---

# About this document

For pre-1.0 versions of Aqueduct, this document is given the same
version number as the package itself. Once the package and/or protocol
hits version 1.0, version numbers for the package and for the protocol
will become independent.

This is a text file with a maximum width of 73 characters. It should be
self-sufficient as a reference for someone creating their own Aqueduct
implementation.

Any code changes that change the protocol should correspond to updates
to this document to keep it up-to-date. We will become more conservative
and intentional about changing the protocol once we hit 1.0.

We use the "-AFTER" suffix on our semantic versions to denote that the
current version of the code / specification belongs to some commit after
the release-tagged commit corresponding to that version of the code, and
before the next release-tagged commit corresponding to the following
version.

Pre-1.0 versions of this document may include TODO comments with notes
on ways we would like to explore potentially enhancing the protocol. A
TODO comment noting some idea does not constitute a commitment or
promise to actually going through with it.

# Glossary

- Aqueduct: This protocol.
- QUIC: The QUIC protocol, as first standardized in RFC 9000, which
  Aqueduct runs on.
- TLS: The encryption protocol which QUIC is fused with.
- ZeroRTT: A feature provided by QUIC and TLS, also known as TLS Early
  Data, or TLS (Stateless) Session Resumption, or 0-RTT.
- Stream: A QUIC byte stream.
- Bidirectional / Unidirectional stream: Streams being bidirectional or
  unidirectional is a feature of QUIC streams, provided by QUIC.
- Datagram: A QUIC unreliable datagram, as per the QUIC unreliable
  datagram extension first standardized in RFC 9221.
- Connection: An Aqueduct connection between two sides of the Aqueduct
  connection, which wraps around a QUIC connection.
- Client: The side of the Aqueduct connection which initiated the
  connection.
- Server: The side of the Aqueduct connection which is not the client.
- Channel: A networked channel of messages within an Aqueduct
  connection, which is the main abstraction exposed by Aqueduct to the
  application.
- Oneshot channel: A channel that may only ever have up to 1 message
  sent on it, created like that intentionally by the application.
- Message: A discrete message sent by the application on a channel.
- Payload: The part of a message which is a byte array encoded by
  application-provided serialization logic.
- Attachment: A relationship between a message and a channel, wherein a
  new channel may be created by attaching it to a message that is sent
  on an existing channel.
- Frame: A unit of Aqueduct protocol communication, written by one side
  of the Aqueduct connection to a stream or datagram and read by the
  other side, without being exposed to the application.

# QUIC

Aqueduct runs on top of QUIC. In this document, "streams" refers to QUIC
streams, whereas "channels" refers to Aqueduct channels. QUIC datagrams
are also used.

Servers and client must accept datagrams (they must have enabled the
QUIC unreliable datagram extension first standardized in RFC 9221). If
they do not, they are not compliant Aqueduct implementations, and this
may be treated as a protocol error.

TODO: Fallback to TCP or WebSocket for situations where the network
      refuses to carry UDP packets.
TODO: Fallback, or completely convert to WebTransport for running within
      web frontends more performantly than falling back to WebSocket.

# ZeroRTT

An Aqueduct client may send any data in 0-RTT streams and 0-RTT
datagrams. It must buffer all data sent on 0-RTT streams until it learns
the server accepted or rejected its 0-RTT data. If the server rejects
its 0-RTT data, it must retransmit all data it sent on a 0-RTT stream on
a new 1-RTT stream. It should not buffer and retransmit datagrams.

If a handle to a stream opened in 0-RTT mode is being held somewhere in
Aqueduct's state, and Aqueduct is forced is re-transmit the buffered
data in a new 1-RTT stream as described above, it must replace the old
stream with the new one at the place where it's storing it in its state.

Clients should remember address validation tokens from NEW_TOKEN frames
and use them when making 0-RTT requests if able. Transmitting 0-RTT data
will not be beneficial if the client does not have an address validation
token, so a client may avoid bothering to do so if it doesn't.

An Aqueduct server may receive data from 0-RTT streams, but it must not
process it until it can be sure it is not coming from a replay attack.
If the client used some un-guessable and un-forgeable address validation
token, and the server maintains state capable of detecting token reuse,
and this system is guaranteed to experience no false negatives with
regard to detecting token reuse, and from this system the server knows
that the client's address validation token has never been used before,
then the server may conclude that the 0-RTT data is definitely not
coming from a replay attack, and process it immediately. In such a
system, the server must take care to ensure that this token reuse
detection state is at least as persistent as whatever cryptographic keys
or other mechanism it is using to prevent its tokens from being guessed
or forged. The server also must ensure that there are also no
possibilities for false negatives introduced by problems relating to
token encryption keys being shared by servers in a server farm or
cluster, or by eventual consistency in replay detection state being
shared, replicated, sharded, or otherwise distributed across different
servers in a server farm or cluster, or by lack of consistency in the
face of un-graceful server shutdown, or by systems to copy or roll back
disk state, or by anything else. If the server is using validation
tokens to protect against replay attacks as such, it also of course must
remember to actually check whether a connection is validated. If the
server cannot for any reason determine with total confidence that 0-RTT
data is not coming from replay attacks, it must either reject the 0-RTT
data on the TLS level (QUIC/TLS APIs may not always make this possible),
or wait until the TLS handshake fully completes before processing that
data, at which point the completion of the TLS handshake proves the
authenticity of the 0-RTT data.

An Aqueduct server always may send data as 0.5-RTT data, and should
do so if it is or may be processing 0-RTT data.

TODO: Conveying that data was sent in 0-RTT and getting responses of
      whether it was accepted or rejected without relying on TLS API
      itself, to facilitate proxies / reverse proxies and/or limited
      TLS APIs.
TODO: Conveying the proof-of-no-replay token through some other field
      than that address validation token, to deal with limited TLS APIs.
TODO: TLS client authentication, both in general, and also getting that
      to work security in 0.5-RTT by encoding some information about a
      previously authenticated session in the token. Consider security
      issues with a client, potentially a proxy, reusing a token but
      not actually meaning to authenticate its further requests with the
      old client key. Consider whether this has tradeoffs with
      cryptographic forward security and how to navigate those.

# Endianness

Values are encoded little-endian unless stated otherwise.

# Var len ints

Sometimes, a variable length uint encoding is used. An encoded var len
int always contains at least 1 byte. The lowest 7 bits of the byte
encode the lowest 7 bits of the represented uint, and the highest bit of
the byte is a 1 if there is at least 1 more byte in the encoded var len
int. If there is another byte in the encoded var len int, the lowest 7
bits of that byte encode the next lowest 7 bits of the represented uint
(so, the 8th through 14th lowest bits), and the highest bit represents
whether there is yet another byte in the encoded uint. This pattern
continues until terminated by an encoded byte with its highest bit being
0. It must be considered a protocol violation if a var len int is
encoded in more bytes than necessary, or if it contains more than 64
bits, excepting unavoidable trailing 0 bits.

# Byte arrays

Sometimes, a length-prefixed byte array is encoded. This is encoded as a
var len int, encoding the length of the array, following by that many
bytes.

# Channel IDs

Each (networked) channel and oneshot channel within a connection has a
64-bit channel ID.

- The lowest bit is a 0 if the channel is flowing from the client to the
  server, and 1 if it is flowing from the server to the client.
- The second lowest bit is a 0 if the channel ID was minted by the
  client, and a 1 if it was minted by the server.
- The third lowest bit is a 0 if the channel is not a oneshot channel,
  and a 1 if it is a oneshot channel.
- The other 61 bits are the "channel idx", a 61-bit uint.

When channel IDs are minted, the side minting them assigns them channel
idxs seqeuentially within their index space, which is defined by the
other 3 bits, starting at 0.

The channel ID which consists entirely of zeroes (flowing towards
server, created by client, not oneshot index 0) is considered the
"entrypoint channel" and treated specially in some cases.


