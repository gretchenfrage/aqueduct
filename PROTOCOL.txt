The Aqueduct Protocol Specification
Pre-Release Version: 0.0.0-AFTER
---

# About this document

For pre-1.0 versions of Aqueduct, this document is given the same
version number as the package itself. Once the package and/or protocol
hits version 1.0, version numbers for the package and for the protocol
will become independent.

This is a text file with a maximum width of 73 characters. It should be
self-sufficient as a reference for someone creating their own Aqueduct
implementation.

Any code changes that change the protocol should correspond to updates
to this document to keep it up-to-date. We will become more conservative
and intentional about changing the protocol once we hit 1.0.

We use the "-AFTER" suffix on our semantic versions to denote that the
current version of the code / specification belongs to some commit after
the release-tagged commit corresponding to that version of the code, and
before the next release-tagged commit corresponding to the following
version.

Pre-1.0 versions of this document may include TODO comments with notes
on ways we would like to explore potentially enhancing the protocol. A
TODO comment noting some idea does not constitute a commitment or
promise to actually going through with it.

# Glossary

- Aqueduct: This protocol.
- QUIC: The QUIC protocol, as first standardized in RFC 9000, which
  Aqueduct runs on.
- TLS: The encryption protocol which QUIC is fused with.
- ZeroRTT: A feature provided by QUIC and TLS, also known as TLS Early
  Data, or TLS (Stateless) Session Resumption, or 0-RTT.
- Stream: A QUIC byte stream.
- Bidirectional / Unidirectional stream: Streams being bidirectional or
  unidirectional is a feature of QUIC streams, provided by QUIC.
- Finishing a stream: QUIC has a feature where a stream can be
  "finished". This represents a graceful closing of the stream, in which
  all bytes sent will be retransmitted as necessary until the reader
  reads all bytes from the stream, after which the reader observes that
  the stream has finished. In a bidirectional stream, both sides can be
  finished independently. Not to be confused with finishing a channel.
- Resetting a stream: QUIC has a feature where a stream can be "reset".
  This represents an abrupt closing of the stream, in which the reader
  observes that the stream was reset as soon as possible, and any bytes
  buffered, in-transmit, or needing of retransmission are abandoned. In
  a bidirectional stream, both sides can be reset independently. The
  analogous concept for channels is cancelling the channel.
- Datagram: A QUIC unreliable datagram, as per the QUIC unreliable
  datagram extension first standardized in RFC 9221.
- Connection: An Aqueduct connection between two sides of the Aqueduct
  connection, which wraps around a QUIC connection.
- Client: The side of the Aqueduct connection which initiated the
  connection.
- Server: The side of the Aqueduct connection which is not the client.
- Channel: A networked channel of messages within an Aqueduct
  connection, which is the main abstraction exposed by Aqueduct to the
  application.
- Oneshot channel: A channel that may only ever have up to 1 message
  sent on it, created like that intentionally by the application.
- Message: A discrete message sent by the application on a channel.
- Payload: The part of a message which is a byte array encoded by
  application-provided serialization logic.
- Attachment: A relationship between a message and a channel, wherein a
  new channel may be created by attaching it to a message that is sent
  on an existing channel.
- Finishing a channel: Aqueduct has a feature where a channel can be
  "finished". This represents a graceful closing of the channel, in
  which all messages sent reliably will be received, and all messages
  sent unreliable will be given a reasonable chance to be received,
  after which the receiver observes that the channel has finished. Not
  to be confused with finishing a stream.
- Cancelling a channel: Aqueduct has a feature where a sender can
  "cancel" a channel. This represents an abrupt closing of the channel,
  in which the receiver observes that the channel was cancelled as soon
  as possible, and any messages not yet received are abandoned. The
  analogous concept for streams is resetting the stream.
- Frame: A unit of Aqueduct protocol communication, written by one side
  of the Aqueduct connection to a stream or datagram and read by the
  other side, without being exposed to the application.

# QUIC

Aqueduct runs on top of QUIC. In this document, "streams" refers to QUIC
streams, whereas "channels" refers to Aqueduct channels. QUIC datagrams
are also used.

Servers and client must accept datagrams (they must have enabled the
QUIC unreliable datagram extension first standardized in RFC 9221). If
they do not, they are not compliant Aqueduct implementations, and this
may be treated as a protocol error.

TODO: Fallback to TCP or WebSocket for situations where the network
      refuses to carry UDP packets.
TODO: Fallback, or completely convert to WebTransport for running within
      web frontends more performantly than falling back to WebSocket.

# ZeroRTT

An Aqueduct client may send any data in 0-RTT streams and 0-RTT
datagrams. It must buffer all data sent on 0-RTT streams until it learns
the server accepted or rejected its 0-RTT data. If the server rejects
its 0-RTT data, it must retransmit all data it sent on a 0-RTT stream on
a new 1-RTT stream. It should not buffer and retransmit datagrams.

If a handle to a stream opened in 0-RTT mode is being held somewhere in
Aqueduct's state, and Aqueduct is forced is re-transmit the buffered
data in a new 1-RTT stream as described above, it must replace the old
stream with the new one at the place where it's storing it in its state.

Clients should remember address validation tokens from NEW_TOKEN frames
and use them when making 0-RTT requests if able. Transmitting 0-RTT data
will not be beneficial if the client does not have an address validation
token, so a client may avoid bothering to do so if it doesn't.

An Aqueduct server may receive data from 0-RTT streams, but it must not
process it until it can be sure it is not coming from a replay attack.
If the client used some un-guessable and un-forgeable address validation
token, and the server maintains state capable of detecting token reuse,
and this system is guaranteed to experience no false negatives with
regard to detecting token reuse, and from this system the server knows
that the client's address validation token has never been used before,
then the server may conclude that the 0-RTT data is definitely not
coming from a replay attack, and process it immediately. In such a
system, the server must take care to ensure that this token reuse
detection state is at least as persistent as whatever cryptographic keys
or other mechanism it is using to prevent its tokens from being guessed
or forged. The server also must ensure that there are also no
possibilities for false negatives introduced by problems relating to
token encryption keys being shared by servers in a server farm or
cluster, or by eventual consistency in replay detection state being
shared, replicated, sharded, or otherwise distributed across different
servers in a server farm or cluster, or by lack of consistency in the
face of un-graceful server shutdown, or by systems to copy or roll back
disk state, or by anything else. If the server is using validation
tokens to protect against replay attacks as such, it also of course must
remember to actually check whether a connection is validated. If the
server cannot for any reason determine with total confidence that 0-RTT
data is not coming from replay attacks, it must either reject the 0-RTT
data on the TLS level (QUIC/TLS APIs may not always make this possible),
or wait until the TLS handshake fully completes before processing that
data, at which point the completion of the TLS handshake proves the
authenticity of the 0-RTT data.

An Aqueduct server always may send data as 0.5-RTT data, and should
do so if it is or may be processing 0-RTT data.

TODO: Conveying that data was sent in 0-RTT and getting responses of
      whether it was accepted or rejected without relying on TLS API
      itself, to facilitate proxies / reverse proxies and/or limited
      TLS APIs.
TODO: Conveying the proof-of-no-replay token through some other field
      than that address validation token, to deal with limited TLS APIs.
TODO: TLS client authentication, both in general, and also getting that
      to work security in 0.5-RTT by encoding some information about a
      previously authenticated session in the token. Consider security
      issues with a client, potentially a proxy, reusing a token but
      not actually meaning to authenticate its further requests with the
      old client key. Consider whether this has tradeoffs with
      cryptographic forward security and how to navigate those.

# Endianness

Values are encoded little-endian unless stated otherwise.

# Var len ints

Sometimes, a variable length uint encoding is used. An encoded var len
int always contains at least 1 byte. The lowest 7 bits of the byte
encode the lowest 7 bits of the represented uint, and the highest bit of
the byte is a 1 if there is at least 1 more byte in the encoded var len
int. If there is another byte in the encoded var len int, the lowest 7
bits of that byte encode the next lowest 7 bits of the represented uint
(so, the 8th through 14th lowest bits), and the highest bit represents
whether there is yet another byte in the encoded uint. This pattern
continues until terminated by an encoded byte with its highest bit being
0. It must be considered a protocol violation if a var len int is
encoded in more bytes than necessary, or if it contains more than 64
bits, excepting unavoidable trailing 0 bits.

# Byte arrays

Sometimes, a length-prefixed byte array is encoded. This is encoded as a
var len int, encoding the length of the array, following by that many
bytes.

# Channel IDs

Each (networked) channel and oneshot channel within a connection has a
64-bit channel ID.

- The lowest bit is a 0 if the channel is flowing from the client to the
  server, and 1 if it is flowing from the server to the client.
- The second lowest bit is a 0 if the channel ID was minted by the
  client, and a 1 if it was minted by the server.
- The third lowest bit is a 0 if the channel is not a oneshot channel,
  and a 1 if it is a oneshot channel.
- The other 61 bits are the "channel idx", a 61-bit uint.

When channel IDs are minted, the side minting them assigns them channel
idxs seqeuentially within their index space, which is defined by the
other 3 bits, starting at 0.

The channel ID which consists entirely of zeroes (flowing towards
server, created by client, not oneshot index 0) is considered the
"entrypoint channel" and treated specially in some cases.

Channel IDs are encoded as var len ints.

# Frames

Frames are the unit of the Aqueduct client and server sending each other
self-contained messages on the wire.

Each frame begins with a "frame type byte", a single byte indicating
what type of frame it is. Then, it may have further bytes, in accordance
with logic specific to its frame type.

It is clear from a byte sequence that begins with a frame when that
frame ends. Thus, it is possible to encode multiple frames back-to-back
without additional framing.

The client and server must listen to each other for bidirectional QUIC
streams, unidirectional QUIC streams, and QUIC datagrams. Both the data
in a stream and the data in a datagram is a sequence of one or more
frames encoded back-to-back.

If the data in a stream or in a datagram fails to decode as frames,
that's a protocol violation. If there's extra bytes after the frames,
that's a protocol violation, although it's unclear what that would even
mean as both streams and datagrams are allowed to contain multiple
frames and frames describe their own length implicitly. If a received
QUIC stream is elegantly finished without at least one full frame being
received on it, that's a protocol violation. If a received datagram does
not contain at least one full frame on it, that's a protocol violation.

If multiple frames are received in the same stream or datagram, they
must be processed in sequence (that is, one after the other, in the
order they are encoded). To clarify, if a frame results in a message
being delivered to the application through a channel, there is no
requirement that the application must process these messages in an order
consistent with the order the frames were encoded within the same stream
or datagram. However, there would be a requirement that the Aqueduct
implementation enqueue these messages into the channel in an order
consistent with the order of the frames themselves, as the processing
of a frame which triggers enqueueing a message into an application-
facing channel would encompass just the enqueueing of the message into
the channel, and not the dequeueing and processing of the message by the
application. Frames are abstracted away from the application.

Frames received from different streams or different datagrams may be
processed in parallel.

Parallelizing parts of the processing of frames within the same stream
or datagram is permissible only to the extent that it has no possibility
of meaningfully changing behavior / introducing race conditions.

An Aqueduct implementation does not have to care about whether a frame
came from some particular stream or datagram, or even whether it came
from a stream or a datagram, when processing it.

If a QUIC stream is reset, the receiving side should disregard any
partially received frames up to the point of resetting, and does not
have to process any frames previously received from that stream if it
has not already done so.

NOT FINISHED: describe upgrade frames and bidi streams usage

# Frame types

The following frame type bytes and corresponding frame types exist:

NOT FINISHED: Version numbers

- Version
- ConnectionHeaders
- Message
- 

# Connection control stream

When the Aqueduct client creates the Aqueduct connection, it creates a
QUIC connection to the server. As soon as it can, it opens up a
bidirectional stream, stores it as the "connection control stream", and
sends on it a Version frame, followed by a ConnectionHeaders frame.

When the server observes the QUIC connection opening, it waits to
observe the opening of a bidirectional stream followed by the receiving
on that stream of a Version frame followed by a ConnectionHeaders frame.
Once this occurs, the server stores that stream as the connection
control stream, and sends on it a Version frame, followed by a
ConnectionHeaders frame.

The server may branch on the Version and ConnectionHeaders data it
receives from the client in determining what content to send in its
Version and ConnectionHeaders response. The server may allow the
application to read the client's connection headers and then determine
based on that what connection headers the server has for this
connection.

The client may begin sending message frames to the server before it
receives the server's connection headers. This avoids adding a round
trip to connection start-up time. However, until the client receives the
server's connection headers, it encode a Version frame as the first
frame on any stream or datagram on which it is encoding other frames.
This helps protect the client from accidentally sending data to a server
which is not an Aqueduct server in a way the server could misinterpret,
as a Version frame begins with a shibboleth magic byte sequence.

The server does not have a reason to send any data to the client, on
streams or datagrams, before receiving the client's connection headers.
It must not do so. If in some future version of this protocol the server
gains a reason to do so, care would have to be taken regarding the same
concern mentioned in the last section.

If the server receives frames other than Version and ConnectionHeaders
in any way before it receives the client's ConnectionHeaders frame, it
must wait to process them until it receives the client's
ConnectionHeaders frame. This might occur due to race conditions between
the client sending data on the connection control stream and the client
sending data by other means.

A connection only has 1 connection control stream, and it lasts as long
as the connection. It is a protocol error if the connection control
stream is closed or finished. The client and the server both send a
ConnectionHeaders frame exactly once, on the connection control stream.
The server identifies the connection control stream by it being a
bidirectional stream opened by the client that begins with a Version
frame followed by a ConnectionHeaders frame. It is a protocol error if
either side sends a ConnectionHeaders frame multiple times. It is a
protocol error if the client sends a ConnectionHeaders frame on anything
other than a bidirectional stream, as the second frame on that stream,
wherein the first frame on that stream is a Version frame. It is a
protocol error if the server sends a ConnectionHeaders frame on anything
other than the control stream, as the second frame on that stream,
wherein the first frame on that stream is a Version frame.

# Senders and receivers

At a given point in time, the client and the server both have a set of
senders and receivers. As an intuition, this roughly represents the set
of channels that they think exist.

Each sender / receiver uniquely corresponds to a channel ID. It is a
protocol violation if something would trigger the creation of a sender
on the client for which the channel ID indicates that the client should
be the receiver, or vice versa for receivers, or vice versa for servers.

When the client first initializes, it begins with a single sender, for
the entrypoint channel, and no receivers. When the server first
initializes, it begins with no senders or receivers. After the server
processes the client's ConnectionHeaders, it creates a receiver for the
entrypoint channel.

# Sending messages

On either side, the application can send a message on a channel for
which a sender exists on that side. It does so by sending a message
frame. It may send multiple message frames on the same unidirectional
stream to send them in an ordered fashion, or on different
unidirectional streams to send them in an unordered fashion, or in
datagrams to send them in an unreliable fashion.

It is a protocol error to send message frames on a control stream. It is
a protocol error to send message frames on a bidirectional stream.

# Receiving messages

When a message frame is received and processed, a receiver for its
channel is created if one does not already exist. Then, the message is
enqueued for delivery to the application on that channel.

For every channel attached to the message, the side receiving the
message creates a sender or receiver for the attachment's channel ID,
depending on whether the channel ID indicates that the side that
received the message should have the sender or the receiver for the
attached channel, if such a sender or receiver does not already exist.

When the received message's payload is conveyed to the application, its
attachments (senders and receivers) should also be conveyed with it.
Attached senders should be conveyed in a way that allows the application
to send messages on the channel of the attached sender, and which
facilitates the sender being closed once the application is done with
it. Attached receivers should be conveyed in a way that allows further
messages received on the channel of the attached receiver to be conveyed
to the application such that the application can tell that they have
been received on that channel, and which facilitates the receiver being
closed once the application is done with it.

The Aqueduct implementation should take care to ensure that a received
message which contains senders / receivers which the application did not
expect to be there is not a hazard for causing a memory leak, such as by
making it so that any senders / receivers that the receiving
application's deserialization logic does not claim ownership of are
automatically closed, or that their presence triggers some exception
handling logic that otherwise prevents this from being a problem.

It is a protocol error to attach the same channel to multiple different
messages.

# Channel control streams

When the client or server creates a receiver for a channel, it creates
a bidirectional stream, and stores it as that receiver's "channel
control stream". Immediately after doing so, it sends a ChannelControl
frame on the stream, with the channel ID of the channel for which the
receiver was created.

Both sides of the connection listen for ChannelControl frames received
on bidirectional streams. It is a protocol error for there to be a
ChannelControl frame on a unidirectional stream, or in a datagram, or
in the connection control stream, or for there to be multiple
ChannelControl frames in the same channel control stream.

When a ChannelControl frame is received on its bidirectional stream as
such:

- If the side that received the ChannelControl stream currently has a
  sender for that channel ID, it attaches the bidirectional stream as
  that sender's channel control stream.
- If the side that received the ChannelControl stream currently has a
  sender for that channel ID, but the sender already has a channel
  control stream associated with it, it writes a ChannelClosed frame
  back on the bidirectional stream.

  NOT FINISHED is ChannelClosed correct?

  TODO I don't think this rule causes problems, but we should double-
       check whether it is actually necessary / the best design.
- If the side that received the ChannelControl stream does not currently
  have a sender for that channel ID, it writes a ChannelClosed frame
  back on the bidirectional stream.

  NOT FINISHED is ChannelClosed correct?

# Acks and nacks

In Aqueduct, it is possible for a message frame sent on a channel to not
be received and processed by the receiver, despite the connection as a
whole remaining alive. This can occur due to the sender cancelling the
channel, the receiver closing the channel early, or messages sent
unreliably being lost. The Aqueduct protocol contains a system by which
the receiver of messages can not only ack messages frames it's processed,
but also nack messages frames it's declared lost. Moreover, unlike most
similar systems, nacks experience no false positives, as the receiver
nacking a message actually represents a commitment to never processing
that message, even if it arrives late. Other parts of the Aqueduct
protocol rely on this assurance. Since "exactly once message delivery
is impossible in a distributed system," these systems do not apply to
cases where the QUIC connection as a whole closes.

Each sender maintains two sequential u64 counters for messages it's
sent--one for messages sent reliably (in streams), and one for messages
sent unreliably (in datagrams). A message frame contains its message
number within its appropriate space, which is defined by the channel ID
and whether the message frame is in a stream or datagram.

The sender side of a channel control stream may send SentUnreliable
frames indicating that the highest unreliable message number it has sent
for that channel has increased by a certain amount. When a sender sends
a message unreliably, it must send a SentUnreliable frame indicating
that that unreliable message number was sent within a reasonable amount
of time, such as 0.1 second, or half the estimated RTT. It may wait for
such a delay in anticipation of more unreliable messages potentially
being sent, in the hopes that only a single SentUnreliable frame would
have to be sent to cover a larger range of packet numbers.

When the receiver side of a channel control stream receives a
SentUnreliable frame, it must ack or nack all unreliable messages sent
up to the message number it was raised to after a reasonable loss-
detection delay after the SentUnreliable frame was received, such as 1
second or twice the estimated RTT. It does so by sending an AckNack
frame back on the channel control stream.

TODO nagling-inspired thing instead of arbitrarily chosen durations?

When a receiver nacks some unreliably received message, it must retain
whatever state is necessary to ensure that if it does ever receive that
message frame, it will discard it without processing it. If it did, this
would be a protocol error.

An Aqueduct implementation does not need to explicitly harden itself
from the possibility of an unreliable or other message being received in
duplicate, as the QUIC protocol prevents that from happening.

# Closing channels

When the receiver of a channel finishes a channel, it does so by sending
a FinishSender frame on the channel control stream. This includes the
message


# Error handling

Upon encountering or detecting a protocol error, the QUIC connection
should be immediately closed.

If the QUIC connection closes, the Aqueduct connection closes.
